<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Race Timetable ‚Äì Chronological View</title>

  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css" />

<style>
  :root {
    --gap-between-days: 24px;     /* espacio entre grupos de d√≠as */
    --gap-between-cards: 4px;    /* espacio entre tarjetas del mismo d√≠a */
  }

  /* ==========================
     Sticky day headers
  ========================== */
  .day-separator {
    position: sticky;
    top: 0;
    z-index: 5;
    width: 100%;
    margin-bottom: calc(var(--gap-between-cards) / 2);
    background-color: #fefefe;
    color: #111;
    font-weight: 700;
    font-size: 1em;
    border-radius: 6px;
    padding: 6px 12px;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    box-shadow: 0 2px 4px rgba(255,255,255,0.1);
    box-sizing: border-box;
  }

  /* ==========================
     Scrollable container (days)
  ========================== */
  #all-events {
    width: 90%;
    max-width: 1200px;
    margin: 0 auto;
    display: flex;
    flex-direction: column;
    gap: var(--gap-between-days);
    overflow-y: auto;
    overflow-x: hidden;
    height: calc(100vh - 90px);
    scroll-behavior: smooth;
    padding: 12px 16px 20px 0;
    box-sizing: border-box;
  }

  /* ===== Scrollbar styling (como antes) ===== */
  #all-events::-webkit-scrollbar {
    width: 12px;
  }

  #all-events::-webkit-scrollbar-thumb {
    background-color: #333;
    border-radius: 10px;
  }

  #all-events::-webkit-scrollbar-track {
    background: transparent;
  }

  /* ==========================
     Day group (usa gap moderno)
  ========================== */
  .day-group {
    display: flex;
    flex-direction: column;
    gap: var(--gap-between-cards);
  }

  /* Fallback por si gap no se aplica (antiguos navegadores) */
  .day-group .event-card {
    margin-bottom: var(--gap-between-cards);
  }
  .day-group .event-card:last-child {
    margin-bottom: 0;
  }

  /* ==========================
     Event cards
  ========================== */
  .event-card {
    position: relative;
    width: calc(100% - 16px);
    background: var(--card-bg);
    border-radius: var(--border-radius);
    padding: 14px 20px;
    display: grid;
    grid-template-columns: 1fr 2fr;
    align-items: start; /* ‚úÖ alinea ambas columnas arriba */
    gap: 12px;
    overflow: hidden;
    margin: 0;
    transition: transform 0.2s ease, box-shadow 0.2s ease, background-color 0.3s ease;
    box-sizing: border-box;
  }

  .event-card:hover {
    transform: translateY(-3px);
    box-shadow: 0 4px 16px rgba(255,254,0,0.25);
  }

  .event-card.active {
    background-color: var(--tertiary-bg-active);
    box-shadow: 0 0 12px rgba(0,255,100,0.25);
  }

  /* Progress bar */
  .progress-bar {
    position: absolute;
    bottom: 0;
    left: 0;
    height: 4px;
    background: var(--accent-green);
    width: 0%;
    border-bottom-left-radius: var(--border-radius);
    border-bottom-right-radius: var(--border-radius);
    transition: width 0.5s linear;
  }

  /* Category badges */
  .badge {
    display: inline-block;
    padding: 3px 8px;
    border-radius: 8px;
    font-size: 0.6em;
    font-weight: 700;
    color: #111;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-top: 4px;
  }

  .badge.main { background-color: red; }
  .badge.secondary { background-color: yellow; color: #111; }
  .badge.tertiary { background-color: green; color: #111; }

  .info-left {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: flex-start;
    text-align: left;
    gap: 4px;
  }

  .info-left .title {
    font-size: 1.2em;
    font-weight: 700;
    color: var(--text-color);
    line-height: 1.2;
  }

  .info-right {
    display: flex;
    flex-direction: column;
    justify-content: flex-start; /* ‚úÖ fuerza el bloque a estar arriba */
    align-items: flex-end;       /* ‚úÖ alinea todo el contenido a la derecha */
    gap: 6px;
    text-align: right;
  }

  .info-right .datetime {
    font-size: 1em;
    color: var(--text-color);
  }

  .info-right .description {
    font-size: 1em;
    color: var(--secondary-text);
  }

  .info-right .location {
  font-size: 0.9em;
  color: #aaa;
  font-style: italic;
  margin-top:2px;
}


  @media (max-width: 800px) {
    .event-card {
      grid-template-columns: 1fr;
      text-align: left;
    }
    .info-right {
      text-align: left;
    }
  }
</style>





</head>
<body>
  <!-- ==========================
       üèÅ Header
  ========================== -->
  <header>
    <div class="logo">
      <img src="logo.svg" alt="Iron Lynx Logo" class="logo-img" />
    </div>
    <div class="header-title">Race Timetable ‚Äì Chronological View</div>
    <div id="current-datetime" style="cursor:pointer;" onclick="window.location.href='index.html'">
      <div class="date-line">Loading‚Ä¶</div>
      <div class="time-line">--:--:--</div>
    </div>
  </header>

  <!-- ==========================
       üìÖ Events
  ========================== -->
  <main>
    <div id="all-events"></div>
  </main>

  <!-- ==========================
       ‚öôÔ∏è Script
  ========================== -->
  <script>


  const SHOW_LOCATION = true; // ‚úÖ Mostrar ubicaci√≥n si est√° en el ICS


  async function loadAllEvents() {
    const container = document.getElementById("all-events");
    try {
      const configResp = await fetch("calendars.json");
      const ICS_SOURCES = await configResp.json();

      const fetchICS = async (urls, category) => {
        const all = await Promise.all(
          urls.map(async (u) => {
            const proxied = "https://calendar-proxy.rubencasanovaarribas.workers.dev/?url=" + encodeURIComponent(u);
            const resp = await fetch(proxied);
            const text = await resp.text();
            return parseICS(text).map(e => ({ ...e, category }));
          })
        );
        return all.flat();
      };

      const [mainEvents, secondaryEvents, tertiaryEvents] = await Promise.all([
        fetchICS(ICS_SOURCES.main || [], "main"),
        fetchICS(ICS_SOURCES.secondary || [], "secondary"),
        fetchICS(ICS_SOURCES.tertiary || [], "tertiary"),
      ]);

      const allEvents = [...mainEvents, ...secondaryEvents, ...tertiaryEvents];
      allEvents.sort((a, b) => new Date(a.start) - new Date(b.start));

      container.innerHTML = "";
      renderEventsByDay(allEvents, container);
      scrollToCurrentEvent(allEvents);
    } catch (err) {
      console.error(err);
      container.innerHTML = "Error loading ICS events.";
    }
  }

  // ==============================================
// üìÖ ICS PARSER v1 (con soporte TZID + Windows ‚Üí IANA + conversi√≥n UTC real sin DST)
// ==============================================
function parseICS(text) {
  const events = [];
  const normalized = text.replace(/\r\n/g, "\n").replace(/\n /g, "");
  const blocks = normalized.split("BEGIN:VEVENT").slice(1);

  for (const block of blocks) {
    const endBlock = block.split("END:VEVENT")[0];
    const summary = matchField(endBlock, "SUMMARY") || "Untitled";
    const description = matchField(endBlock, "DESCRIPTION") || "";
    const location = matchField(endBlock, "LOCATION") || "";
    const start = matchField(endBlock, "DTSTART");
    const end = matchField(endBlock, "DTEND");

    const startISO = parseICSTime(start, endBlock, "START");
    const endISO = parseICSTime(end, endBlock, "END");

    events.push({ title: summary, description, location, start: startISO, end: endISO });
  }
  return events;
}

// ==============================================
// üîç Extrae campos ICS
// ==============================================
function matchField(block, key) {
  const regex = new RegExp(`${key}(?:;[^:]+)?:([^\n\r]+)`);
  const match = block.match(regex);
  if (!match) return null;
  return match[1].trim().replace(/\\n/g, "\n").replace(/\\\\/g, "\\");
}

// ==============================================
// üïí Conversi√≥n ICS ‚Üí ISO (sin DST, siempre UTC real)
// ==============================================
function parseICSTime(value, block = "", label = "") {
  if (!value) return null;

  // Detectar zona horaria (TZID)
  const tzMatch = block.match(/TZID=([^:;]+)/);
  let tzid = tzMatch ? tzMatch[1].trim() : null;
  if (tzid) tzid = convertWindowsToIANA(tzid);

  // üìÖ Fecha sin hora
  if (/^\d{8}$/.test(value)) {
    return `${value.slice(0,4)}-${value.slice(4,6)}-${value.slice(6,8)}T00:00:00Z`;
  }

  // üïò Hora UTC expl√≠cita
  if (/^\d{8}T\d{6}Z$/.test(value)) {
    return `${value.slice(0,4)}-${value.slice(4,6)}-${value.slice(6,8)}T${value.slice(9,11)}:${value.slice(11,13)}:${value.slice(13,15)}Z`;
  }

  // üïí Hora local (con o sin TZID)
  if (/^\d{8}T\d{6}$/.test(value)) {
    const year = +value.slice(0,4);
    const month = +value.slice(4,6) - 1;
    const day = +value.slice(6,8);
    const hour = +value.slice(9,11);
    const minute = +value.slice(11,13);
    const second = +value.slice(13,15);

    let baseMs = Date.UTC(year, month, day, hour, minute, second);

    if (tzid) {
      try {
        const offsetMinutes = getStandardOffsetMinutes(tzid);
        const utcMs = baseMs - offsetMinutes * 60 * 1000;
        const utcISO = new Date(utcMs).toISOString();
        console.log(`üïí [${label}] ${value} | TZID: ${tzid} | Offset: ${offsetMinutes} min ‚Üí UTC: ${utcISO}`);
        return utcISO;
      } catch (e) {
        console.warn(`‚ö†Ô∏è TZID '${tzid}' no reconocido ‚Äî usando hora local (${label}).`);
        return new Date(baseMs).toISOString();
      }
    }

    return new Date(baseMs).toISOString();
  }

  return null;
}

// ==============================================
// üßÆ Obtiene offset est√°ndar (sin DST)
// ==============================================
function getStandardOffsetMinutes(tzid) {
  const refDate = new Date(Date.UTC(2025, 0, 1)); // enero, sin horario de verano
  const dtf = new Intl.DateTimeFormat("en-US", {
    timeZone: tzid,
    hour12: false,
    year: "numeric", month: "2-digit", day: "2-digit",
    hour: "2-digit", minute: "2-digit", second: "2-digit"
  });
  const parts = dtf.formatToParts(refDate);
  const vals = Object.fromEntries(parts.map(p => [p.type, p.value]));
  const local = Date.UTC(vals.year, vals.month - 1, vals.day, vals.hour, vals.minute, vals.second);
  const diffMinutes = (local - refDate.getTime()) / 60000;
  return diffMinutes;
}

// ==============================================
// üåç Conversi√≥n Windows TZ ‚Üí IANA
// ==============================================
const WINDOWS_TZ_MAP = {
  "Dateline Standard Time": "Etc/GMT+12",
  "UTC-11": "Etc/GMT+11",
  "Hawaiian Standard Time": "Pacific/Honolulu",
  "Alaskan Standard Time": "America/Anchorage",
  "Pacific Standard Time": "America/Los_Angeles",
  "Mountain Standard Time": "America/Denver",
  "US Mountain Standard Time": "America/Phoenix",
  "Central Standard Time": "America/Chicago",
  "Eastern Standard Time": "America/New_York",
  "Atlantic Standard Time": "America/Halifax",
  "SA Pacific Standard Time": "America/Bogota",
  "Venezuela Standard Time": "America/Caracas",
  "Paraguay Standard Time": "America/Asuncion",
  "Argentina Standard Time": "America/Argentina/Buenos_Aires",
  "Greenland Standard Time": "America/Godthab",
  "E. South America Standard Time": "America/Sao_Paulo",
  "Montevideo Standard Time": "America/Montevideo",
  "Newfoundland Standard Time": "America/St_Johns",
  "Bahia Standard Time": "America/Bahia",
  "Azores Standard Time": "Atlantic/Azores",
  "Cape Verde Standard Time": "Atlantic/Cape_Verde",
  "Morocco Standard Time": "Africa/Casablanca",
  "UTC": "Etc/UTC",
  "GMT Standard Time": "Europe/London",
  "Greenwich Standard Time": "Atlantic/Reykjavik",
  "W. Europe Standard Time": "Europe/Berlin",
  "Central Europe Standard Time": "Europe/Budapest",
  "Romance Standard Time": "Europe/Paris",
  "Central European Standard Time": "Europe/Warsaw",
  "W. Central Africa Standard Time": "Africa/Lagos",
  "Namibia Standard Time": "Africa/Windhoek",
  "Jordan Standard Time": "Asia/Amman",
  "GTB Standard Time": "Europe/Bucharest",
  "Middle East Standard Time": "Asia/Beirut",
  "Egypt Standard Time": "Africa/Cairo",
  "Syria Standard Time": "Asia/Damascus",
  "E. Europe Standard Time": "Europe/Chisinau",
  "South Africa Standard Time": "Africa/Johannesburg",
  "FLE Standard Time": "Europe/Kiev",
  "Turkey Standard Time": "Europe/Istanbul",
  "Arab Standard Time": "Asia/Riyadh",
  "Russian Standard Time": "Europe/Moscow",
  "E. Africa Standard Time": "Africa/Nairobi",
  "Iran Standard Time": "Asia/Tehran",
  "Arabian Standard Time": "Asia/Dubai",
  "Azerbaijan Standard Time": "Asia/Baku",
  "Mauritius Standard Time": "Indian/Mauritius",
  "Georgian Standard Time": "Asia/Tbilisi",
  "Caucasus Standard Time": "Asia/Yerevan",
  "Afghanistan Standard Time": "Asia/Kabul",
  "West Asia Standard Time": "Asia/Tashkent",
  "Pakistan Standard Time": "Asia/Karachi",
  "India Standard Time": "Asia/Kolkata",
  "Sri Lanka Standard Time": "Asia/Colombo",
  "Nepal Standard Time": "Asia/Kathmandu",
  "Central Asia Standard Time": "Asia/Almaty",
  "Bangladesh Standard Time": "Asia/Dhaka",
  "Myanmar Standard Time": "Asia/Yangon",
  "SE Asia Standard Time": "Asia/Bangkok",
  "N. Central Asia Standard Time": "Asia/Novosibirsk",
  "China Standard Time": "Asia/Shanghai",
  "North Asia Standard Time": "Asia/Krasnoyarsk",
  "Singapore Standard Time": "Asia/Singapore",
  "W. Australia Standard Time": "Australia/Perth",
  "Taipei Standard Time": "Asia/Taipei",
  "Ulaanbaatar Standard Time": "Asia/Ulaanbaatar",
  "North Asia East Standard Time": "Asia/Irkutsk",
  "Korea Standard Time": "Asia/Seoul",
  "Tokyo Standard Time": "Asia/Tokyo",
  "Yakutsk Standard Time": "Asia/Yakutsk",
  "Cen. Australia Standard Time": "Australia/Adelaide",
  "AUS Central Standard Time": "Australia/Darwin",
  "E. Australia Standard Time": "Australia/Brisbane",
  "AUS Eastern Standard Time": "Australia/Sydney",
  "West Pacific Standard Time": "Pacific/Port_Moresby",
  "Tasmania Standard Time": "Australia/Hobart",
  "Vladivostok Standard Time": "Asia/Vladivostok",
  "Central Pacific Standard Time": "Pacific/Guadalcanal",
  "New Zealand Standard Time": "Pacific/Auckland",
  "Tonga Standard Time": "Pacific/Tongatapu",
  "Samoa Standard Time": "Pacific/Apia",
  "Line Islands Standard Time": "Pacific/Kiritimati"
};

function convertWindowsToIANA(tzid) {
  return WINDOWS_TZ_MAP[tzid] || tzid;
}


  // ---------- RENDER ----------
  function renderEventsByDay(events, container) {
    const grouped = groupEventsByDay(events);
    Object.keys(grouped).forEach(day => {
      const dayGroup = document.createElement("div");
      dayGroup.className = "day-group"; // ‚úÖ esta clase hace que funcione el gap
      const dayHeader = document.createElement("div");
      dayHeader.className = "day-separator";
      dayHeader.textContent = formatDayLabel(day);
      dayGroup.appendChild(dayHeader);

      grouped[day].forEach(ev => {
        const card = createEventCard(ev);
        dayGroup.appendChild(card);
        updateProgress(ev, card);
        setInterval(() => updateProgress(ev, card), 1000);
      });

      container.appendChild(dayGroup);
    });
  }

  function groupEventsByDay(events) {
    const groups = {};
    events.forEach(ev => {
      const dayKey = new Date(ev.start).toISOString().split("T")[0];
      if (!groups[dayKey]) groups[dayKey] = [];
      groups[dayKey].push(ev);
    });
    return groups;
  }

  function createEventCard(ev) {
    const card = document.createElement("div");
    card.className = `event-card ${ev.category}`;

    // Mostrar ubicaci√≥n si SHOW_LOCATION est√° activado
    const locationHTML =
      SHOW_LOCATION && ev.location
        ? `<div class="location">üìç ${ev.location}</div>`
        : "";

    card.innerHTML = `
      <div class="info-left">
        <div class="title">${ev.title}</div>
        <div class="badge ${ev.category}">${ev.category}</div>
      </div>
      <div class="info-right">
        <div class="datetime">
          ${formatTime(ev.start)} ‚Äî ${formatTime(ev.end)}
        </div>
        ${locationHTML}
        <div class="description">${ev.description || ""}</div>
      </div>
      <div class="progress-bar"></div>
    `;

    return card;
  }


  function updateProgress(ev, card) {
    const now = new Date().getTime();
    const start = new Date(ev.start).getTime();
    const end = new Date(ev.end).getTime();
    const progress = card.querySelector(".progress-bar");

    if (now >= start && now < end) {
      const total = end - start;
      const elapsed = now - start;
      const percent = (elapsed / total) * 100;
      progress.style.width = percent + "%";
      progress.style.display = "block";
      card.classList.add("active");
    } else {
      progress.style.display = "none";
      card.classList.remove("active");
    }
  }

  function formatDayLabel(dateString) {
    const d = new Date(dateString);
    return d.toLocaleDateString("en-GB", {
      weekday: "long",
      day: "2-digit",
      month: "long",
      year: "numeric"
    });
  }

  function formatTime(dtStr) {
    const d = new Date(dtStr);
    return d.toLocaleTimeString("en-GB", {
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      hour12: false
    });
  }

  function scrollToCurrentEvent(events) {
    const now = Date.now();

    // Prefer event currently in progress; if none, next future event
    const current = events.find(ev => new Date(ev.start).getTime() <= now && new Date(ev.end).getTime() > now);
    const next = events.find(ev => new Date(ev.start).getTime() > now);
    const target = current || next;
    if (!target) return;

    // slight delay so DOM is rendered
    setTimeout(() => {
      const container = document.getElementById("all-events");
      if (!container) return;

      const cards = Array.from(container.querySelectorAll(".event-card"));
      const targetCard = cards.find(card => {
        const t = card.querySelector(".title");
        return t && t.textContent === target.title;
      });
      if (!targetCard) return;

      // measure header height (if any)
      const headerEl = document.querySelector("header");
      const headerHeight = headerEl ? headerEl.offsetHeight : 0;

      // find the day-separator that belongs to this card (it is the .day-separator inside the same day-group)
      let dayGroup = targetCard.closest(".day-group");
      let sepHeight = 0;
      if (dayGroup) {
        const sep = dayGroup.querySelector(".day-separator");
        if (sep) sepHeight = sep.offsetHeight;
      }

      // compute card top relative to the scrollable container
      const cardRect = targetCard.getBoundingClientRect();
      const containerRect = container.getBoundingClientRect();
      const relativeTop = cardRect.top - containerRect.top + container.scrollTop;

      // offset so the card appears just under the day-separator + header
      const extraMargin = -68; // small breathing space
      const targetScroll = Math.max(0, relativeTop - sepHeight - headerHeight - extraMargin);

      // perform smooth scroll on the container
      container.scrollTo({
        top: targetScroll,
        behavior: "smooth"
      });
    }, 180); // small timeout to ensure rendering/layout
  }



  function updateCurrentDateTime() {
    const now = new Date();
    document.querySelector("#current-datetime .date-line").textContent =
      now.toLocaleDateString("en-GB", { weekday: "long", day: "2-digit", month: "long", year: "numeric" });
    document.querySelector("#current-datetime .time-line").textContent =
      now.toLocaleTimeString("en-GB", { hour: "2-digit", minute: "2-digit", second: "2-digit", hour12: false });
  }

  setInterval(updateCurrentDateTime, 1000);
  updateCurrentDateTime();
  loadAllEvents();
</script>


</body>
</html>





